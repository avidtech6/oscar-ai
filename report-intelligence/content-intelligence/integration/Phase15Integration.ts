/**
 * Phase 17: Content Intelligence & Blog Post Engine
 * Integration with Phase 15: HTML Rendering & Visual Reproduction Engine
 * 
 * Provides visual rendering capabilities for content intelligence components,
 * enabling high-fidelity HTML/PDF output for blog posts, reports, and other
 * content generated by the content intelligence system.
 * 
 * This integration allows content intelligence components to:
 * 1. Render structured content as visually accurate HTML
 * 2. Generate PDF exports with proper layout and typography
 * 3. Create visual previews for content editing
 * 4. Capture visual snapshots for gallery and reproduction testing
 * 5. Apply brand styling and tone through visual rendering
 */

import type {
  RenderingOptions,
  DocumentContent,
  RenderingResult,
  SectionElement,
  ContentElement
} from '../../visual-rendering/types';

import { VisualRenderingEngine } from '../../visual-rendering/engines/VisualRenderingEngine';
import { SnapshotCaptureSystem } from '../../visual-rendering/engines/SnapshotCaptureSystem';
import { DEFAULT_RENDERING_OPTIONS } from '../../visual-rendering/types';

// Import content intelligence types
import type {
  BlogPost,
  BrandProfile,
  MediaItem,
  ContentTemplate,
  SEOData,
  BrandTone
} from '../types';

/**
 * Content rendering options specific to content intelligence
 */
export interface ContentRenderingOptions extends RenderingOptions {
  contentIntelligence?: {
    applyBrandTone: boolean;
    applySEOOptimization: boolean;
    includeGallery: boolean;
    includeSocialPreview: boolean;
    includePrintLayout: boolean;
    includeAccessibilityFeatures: boolean;
    generateAltText: boolean;
    optimizeImages: boolean;
    includeTableOfContents: boolean;
    includeRelatedContent: boolean;
  };
  blogPost?: {
    includeAuthorBio: boolean;
    includePublicationDate: boolean;
    includeReadingTime: boolean;
    includeCommentsSection: boolean;
    includeShareButtons: boolean;
    includeNewsletterSignup: boolean;
    includeRelatedPosts: boolean;
    includeCategoryTags: boolean;
  };
  gallery?: {
    layout: 'grid' | 'masonry' | 'carousel' | 'slideshow';
    columns: number;
    spacing: number;
    includeCaptions: boolean;
    includeMetadata: boolean;
    includeDownloadLinks: boolean;
    includeLightbox: boolean;
    autoPlay: boolean;
    loop: boolean;
  };
}

/**
 * Enhanced rendering result with content intelligence metadata
 */
export interface ContentRenderingResult extends RenderingResult {
  contentIntelligence?: {
    seoScore?: number;
    readabilityScore?: number;
    toneMatchScore?: number;
    accessibilityScore?: number;
    estimatedReadingTime?: number;
    wordCount?: number;
    paragraphCount?: number;
    headingCount?: number;
    imageCount?: number;
    linkCount?: number;
    mediaCount?: number;
  };
  blogPost?: {
    author?: string;
    publicationDate?: Date;
    readingTime?: string;
    category?: string;
    tags?: string[];
    featuredImage?: string;
    excerpt?: string;
  };
  gallery?: {
    itemCount: number;
    layout: string;
    totalSize: number;
    formats: string[];
    dimensions: {
      minWidth: number;
      maxWidth: number;
      minHeight: number;
      maxHeight: number;
    };
  };
}

/**
 * Blog post rendering configuration
 */
export interface BlogPostRenderingConfig {
  template: ContentTemplate;
  brandProfile?: BrandProfile;
  seoAnalysis?: SEOData;
  galleryItems?: MediaItem[];
  socialPreview?: {
    title: string;
    description: string;
    image: string;
    url: string;
  };
  metadata?: Record<string, any>;
}

/**
 * Phase 15 Integration for Content Intelligence
 */
export class Phase15Integration {
  private renderingEngine: VisualRenderingEngine | null = null;
  private snapshotSystem: SnapshotCaptureSystem | null = null;
  private isInitialized: boolean = false;

  constructor() {
    // Initialize on demand
  }

  /**
   * Initialize the integration
   */
  public async initialize(): Promise<void> {
    if (this.isInitialized) {
      return;
    }

    try {
      // Create rendering engine with content-optimized options
      const options: RenderingOptions = {
        ...DEFAULT_RENDERING_OPTIONS,
        layout: {
          ...DEFAULT_RENDERING_OPTIONS.layout,
          size: 'A4',
          orientation: 'portrait',
          margins: {
            top: 25,
            right: 25,
            bottom: 25,
            left: 25
          }
        },
        typography: {
          ...DEFAULT_RENDERING_OPTIONS.typography,
          fontFamily: 'Georgia, "Times New Roman", serif',
          fontSize: 16,
          lineHeight: 1.6
        },
        colors: {
          ...DEFAULT_RENDERING_OPTIONS.colors,
          primary: '#2c3e50',
          secondary: '#3498db',
          accent: '#e74c3c',
          background: '#ffffff',
          text: '#2c3e50'
        }
      };

      this.renderingEngine = new VisualRenderingEngine(options, {
        enablePreview: true,
        enableSnapshots: true,
        enablePDFExport: true,
        enableCoverPages: true,
        enableHeadersFooters: true,
        enableImageOptimization: true,
        enablePageBreaks: true,
        cacheEnabled: true,
        cacheMaxSize: 50,
        parallelProcessing: true,
        maxWorkers: 2,
        defaultQuality: 90,
        defaultFormat: 'png'
      });

      await this.renderingEngine.initialize();
      
      // Create snapshot system for visual content
      this.snapshotSystem = new SnapshotCaptureSystem(options, {
        enabled: true,
        format: 'png',
        quality: 85,
        scale: 1,
        includeBackground: true,
        captureDelay: 200,
        compareThreshold: 0.9,
        maxSnapshots: 100,
        storageLocation: 'file',
        autoCompare: true,
        generateDiff: true,
        diffHighlightColor: '#ff6b6b'
      });

      this.isInitialized = true;

    } catch (error) {
      console.error('Failed to initialize Phase15Integration:', error);
      throw error;
    }
  }

  /**
   * Render a blog post with full content intelligence features
   */
  public async renderBlogPost(
    blogPost: BlogPost,
    config: BlogPostRenderingConfig
  ): Promise<ContentRenderingResult> {
    if (!this.isInitialized || !this.renderingEngine) {
      await this.initialize();
    }

    try {
      // Convert blog post to document content
      const documentContent = this.convertBlogPostToDocument(blogPost, config);
      
      // Render the document
      const renderingResult = await this.renderingEngine!.renderDocument(documentContent);
      
      // Enhance result with content intelligence metadata
      const enhancedResult: ContentRenderingResult = {
        ...renderingResult,
        contentIntelligence: {
          seoScore: config.seoAnalysis?.readabilityScore,
          readabilityScore: this.calculateReadabilityScore(blogPost.content),
          toneMatchScore: config.brandProfile ? this.calculateToneMatchScore(blogPost.content, config.brandProfile.tone) : undefined,
          accessibilityScore: this.calculateAccessibilityScore(blogPost.content),
          estimatedReadingTime: this.calculateReadingTime(blogPost.content),
          wordCount: this.countWords(blogPost.content),
          paragraphCount: this.countParagraphs(blogPost.content),
          headingCount: this.countHeadings(blogPost.content),
          imageCount: blogPost.images.length,
          linkCount: this.countLinks(blogPost.content),
          mediaCount: blogPost.images.length
        },
        blogPost: {
          author: blogPost.authorId,
          publicationDate: blogPost.publishedAt,
          readingTime: this.formatReadingTime(this.calculateReadingTime(blogPost.content)),
          category: blogPost.categories[0],
          tags: blogPost.tags,
          featuredImage: blogPost.featuredImage?.url,
          excerpt: blogPost.excerpt
        }
      };

      // Add gallery metadata if gallery items are present
      if (config.galleryItems && config.galleryItems.length > 0) {
        enhancedResult.gallery = {
          itemCount: config.galleryItems.length,
          layout: config.galleryItems.length > 10 ? 'masonry' : 'grid',
          totalSize: config.galleryItems.reduce((total, item) => total + (item.size || 0), 0),
          formats: Array.from(new Set(config.galleryItems.map(item => item.mimeType))),
          dimensions: {
            minWidth: Math.min(...config.galleryItems.map(item => item.width || 0)),
            maxWidth: Math.max(...config.galleryItems.map(item => item.width || 0)),
            minHeight: Math.min(...config.galleryItems.map(item => item.height || 0)),
            maxHeight: Math.max(...config.galleryItems.map(item => item.height || 0))
          }
        };
      }

      return enhancedResult;

    } catch (error) {
      console.error('Failed to render blog post:', error);
      throw error;
    }
  }

  /**
   * Generate PDF from blog post
   */
  public async generateBlogPostPDF(
    blogPost: BlogPost,
    config: BlogPostRenderingConfig
  ): Promise<{
    pdfBuffer: ArrayBuffer;
    pdfSize: number;
    pageCount: number;
    metadata: any;
  }> {
    if (!this.isInitialized || !this.renderingEngine) {
      await this.initialize();
    }

    try {
      // Convert blog post to document content
      const documentContent = this.convertBlogPostToDocument(blogPost, config);
      
      // Generate PDF
      const pdfResult = await this.renderingEngine!.exportToPDF(documentContent);
      
      return {
        pdfBuffer: pdfResult.buffer,
        pdfSize: pdfResult.size,
        pageCount: pdfResult.pageCount,
        metadata: pdfResult.metadata
      };

    } catch (error) {
      console.error('Failed to generate PDF:', error);
      throw error;
    }
  }

  /**
   * Create visual preview of content
   */
  public async createVisualPreview(
    blogPost: BlogPost,
    config: BlogPostRenderingConfig,
    width: number = 800,
    height: number = 600
  ): Promise<{
    previewUrl: string;
    dimensions: { width: number; height: number };
    snapshotId?: string;
  }> {
    if (!this.isInitialized || !this.renderingEngine || !this.snapshotSystem) {
      await this.initialize();
    }

    try {
      // Convert blog post to document content
      const documentContent = this.convertBlogPostToDocument(blogPost, config);
      
      // Generate preview
      const previewResult = await this.renderingEngine!.renderDocument(documentContent);
      
      // Capture snapshot for gallery
      let snapshotId: string | undefined;
      if (this.snapshotSystem) {
        const snapshots = await this.snapshotSystem.captureDocumentSnapshot(documentContent, ['content-preview', 'blog-post']);
        if (snapshots.length > 0) {
          snapshotId = snapshots[0].id;
        }
      }

      return {
        previewUrl: previewResult.html || '',
        dimensions: { width, height },
        snapshotId
      };

    } catch (error) {
      console.error('Failed to create visual preview:', error);
      throw error;
    }
  }

  /**
   * Capture visual snapshot of rendered content
   */
  public async captureContentSnapshot(
    blogPost: BlogPost,
    config: BlogPostRenderingConfig,
    tags: string[] = ['content-snapshot']
  ): Promise<{
    snapshotId: string;
    snapshotUrl: string;
    dimensions: { width: number; height: number };
    metadata: any;
  }> {
    if (!this.isInitialized || !this.snapshotSystem) {
      await this.initialize();
    }

    try {
      // Convert blog post to document content
      const documentContent = this.convertBlogPostToDocument(blogPost, config);
      
      // Capture snapshot
      const snapshots = await this.snapshotSystem!.captureDocumentSnapshot(documentContent, tags);
      
      if (snapshots.length === 0) {
        throw new Error('Failed to capture snapshot');
      }

      const snapshot = snapshots[0];
      const snapshotEntry = this.snapshotSystem!.getSnapshot(snapshot.id);
      
      if (!snapshotEntry) {
        throw new Error('Snapshot not found in storage');
      }

      return {
        snapshotId: snapshot.id,
        snapshotUrl: snapshotEntry.data,
        dimensions: snapshot.dimensions,
        metadata: snapshot
      };

    } catch (error) {
      console.error('Failed to capture content snapshot:', error);
      throw error;
    }
  }

  /**
   * Compare visual snapshots of content versions
   */
  public async compareContentVersions(
    originalBlogPost: BlogPost,
    updatedBlogPost: BlogPost,
    config: BlogPostRenderingConfig
  ): Promise<{
    visualSimilarity: number;
    layoutChanges: number;
    contentChanges: number;
    styleChanges: number;
    differences: Array<{
      type: 'layout' | 'content' | 'style' | 'media';
      description: string;
      severity: 'low' | 'medium' | 'high';
    }>;
  }> {
    if (!this.isInitialized || !this.snapshotSystem) {
      await this.initialize();
    }

    try {
      // Capture snapshots of both versions
      const originalSnapshot = await this.captureContentSnapshot(originalBlogPost, config, ['original-version']);
      const updatedSnapshot = await this.captureContentSnapshot(updatedBlogPost, config, ['updated-version']);

      // Compare snapshots
      const comparison = await this.snapshotSystem!.compareSnapshots(
        originalSnapshot.snapshotId,
        updatedSnapshot.snapshotId
      );

      // Analyze differences
      const differences = this.analyzeContentDifferences(
        originalBlogPost,
        updatedBlogPost,
        comparison
      );

      return {
        visualSimilarity: comparison.similarity,
        layoutChanges: this.calculateLayoutChanges(comparison),
        contentChanges: this.calculateContentChanges(originalBlogPost, updatedBlogPost),
        styleChanges: this.calculateStyleChanges(comparison),
        differences
      };

    } catch (error) {
      console.error('Failed to compare content versions:', error);
      throw error;
    }
  }

  /**
   * Convert blog post to document content for rendering
   */
  private convertBlogPostToDocument(
    blogPost: BlogPost,
    config: BlogPostRenderingConfig
  ): DocumentContent {
    // Parse content into sections
    const sections = this.parseContentIntoSections(blogPost.content);
    
    // Convert sections to SectionElement format
    const sectionElements: SectionElement[] = sections.map((section, index) => ({
      id: `section-${index}`,
      title: section.heading || '',
      content: [
        {
          id: `content-${index}-0`,
          type: 'paragraph',
          content: section.content,
          metadata: {
            wordCount: section.wordCount,
            readingTime: section.estimatedReadingTime
          }
        } as ContentElement
      ],
      level: section.level || 1,
      type: 'section',
      metadata: {
        wordCount: section.wordCount,
        readingTime: section.estimatedReadingTime
      }
    }));

    return {
      title: blogPost.title,
      author: blogPost.authorId,
      date: blogPost.publishedAt || new Date(),
      version: '1.0',
      sections: sectionElements,
      metadata: {
        ...blogPost.metadata,
        categories: blogPost.categories,
        tags: blogPost.tags,
        featuredImage: blogPost.featuredImage?.url,
        excerpt: blogPost.excerpt,
        seoTitle: config.seoAnalysis?.title || blogPost.title,
        seoDescription: config.seoAnalysis?.description || blogPost.excerpt,
        brand: config.brandProfile?.id,
        template: config.template.name
      }
    };
  }

  /**
   * Parse content into sections for rendering
   */
  private parseContentIntoSections(content: string): Array<{
    heading?: string;
    content: string;
    level?: number;
    wordCount: number;
    estimatedReadingTime: number;
  }> {
    // Simple parsing: split by headings (h1-h6)
    const headingRegex = /<h([1-6])[^>]*>(.*?)<\/h\1>/gi;
    const sections: Array<{
      heading?: string;
      content: string;
      level?: number;
      wordCount: number;
      estimatedReadingTime: number;
    }> = [];

    let lastIndex = 0;
    let match;

    while ((match = headingRegex.exec(content)) !== null) {
      const level = parseInt(match[1], 10);
      const headingText = match[2].replace(/<[^>]*>/g, '').trim();
      const headingStart = match.index;
      
      // Extract content before this heading
      if (headingStart > lastIndex) {
        const sectionContent = content.substring(lastIndex, headingStart).trim();
        if (sectionContent) {
          sections.push({
            content: sectionContent,
            wordCount: this.countWords(sectionContent),
            estimatedReadingTime: this.calculateReadingTimeForText(sectionContent)
          });
        }
      }

      // Find content after this heading (up to next heading or end)
      const nextHeadingMatch = headingRegex.exec(content);
      headingRegex.lastIndex = match.index + match[0].length;
      
      let sectionContent = '';
      if (nextHeadingMatch) {
        sectionContent = content.substring(match.index + match[0].length, nextHeadingMatch.index).trim();
        headingRegex.lastIndex = nextHeadingMatch.index;
      } else {
        sectionContent = content.substring(match.index + match[0].length).trim();
      }

      sections.push({
        heading: headingText,
        content: sectionContent,
        level,
        wordCount: this.countWords(sectionContent),
        estimatedReadingTime: this.calculateReadingTimeForText(sectionContent)
      });
      lastIndex = match.index + match[0].length + sectionContent.length;
    }

    // Add any remaining content after the last heading
    if (lastIndex < content.length) {
      const remainingContent = content.substring(lastIndex).trim();
      if (remainingContent) {
        sections.push({
          content: remainingContent,
          wordCount: this.countWords(remainingContent),
          estimatedReadingTime: this.calculateReadingTimeForText(remainingContent)
        });
      }
    }

    return sections;
  }

  /**
   * Calculate readability score for content (simplified Flesch-Kincaid)
   */
  private calculateReadabilityScore(content: string): number {
    // Simple implementation: count words and sentences
    const words = content.split(/\s+/).filter(w => w.length > 0);
    const sentences = content.split(/[.!?]+/).filter(s => s.trim().length > 0);
    
    if (words.length === 0 || sentences.length === 0) {
      return 100; // Perfect score for empty content
    }
    
    const wordsPerSentence = words.length / sentences.length;
    const syllablesPerWord = 1.5; // Approximation
    
    // Flesch Reading Ease formula (simplified)
    const score = 206.835 - (1.015 * wordsPerSentence) - (84.6 * syllablesPerWord);
    
    // Normalize to 0-100 scale
    return Math.max(0, Math.min(100, score));
  }

  /**
   * Calculate tone match score between content and brand tone
   */
  private calculateToneMatchScore(content: string, brandTone: BrandTone): number {
    // Simple implementation: check for tone indicators
    const toneWords: Record<string, string[]> = {
      formal: ['therefore', 'however', 'furthermore', 'consequently', 'nevertheless'],
      casual: ['hey', 'awesome', 'cool', 'great', 'nice', 'fun'],
      professional: ['implement', 'strategy', 'optimize', 'leverage', 'synergy'],
      friendly: ['welcome', 'hello', 'thanks', 'appreciate', 'happy'],
      technical: ['algorithm', 'implementation', 'architecture', 'protocol', 'framework']
    };

    const contentLower = content.toLowerCase();
    let matches = 0;
    let total = 0;

    for (const [tone, words] of Object.entries(toneWords)) {
      if (brandTone[tone as keyof BrandTone]) {
        total += words.length;
        matches += words.filter(word => contentLower.includes(word)).length;
      }
    }

    return total > 0 ? (matches / total) * 100 : 0;
  }

  /**
   * Calculate accessibility score for content
   */
  private calculateAccessibilityScore(content: string): number {
    let score = 100;
    
    // Check for headings structure
    const headingRegex = /<h([1-6])[^>]*>/gi;
    const headings: number[] = [];
    let match;
    while ((match = headingRegex.exec(content)) !== null) {
      headings.push(parseInt(match[1], 10));
    }
    
    // Penalize missing headings or improper hierarchy
    if (headings.length === 0) {
      score -= 20;
    } else {
      // Check for proper hierarchy (h1 should come before h2, etc.)
      let lastLevel = 0;
      for (const level of headings) {
        if (level > lastLevel + 1) {
          score -= 10; // Skipped heading level
        }
        lastLevel = level;
      }
    }
    
    // Check for alt text in images
    const imgRegex = /<img[^>]*>/gi;
    const imgCount = (content.match(imgRegex) || []).length;
    const altRegex = /alt=["'][^"']*["']/gi;
    const altCount = (content.match(altRegex) || []).length;
    
    if (imgCount > 0 && altCount < imgCount) {
      score -= (imgCount - altCount) * 5;
    }
    
    // Check for link text
    const linkRegex = /<a[^>]*>(.*?)<\/a>/gi;
    const links = content.match(linkRegex) || [];
    const emptyLinks = links.filter(link => link.replace(/<[^>]*>/g, '').trim().length === 0);
    score -= emptyLinks.length * 10;
    
    return Math.max(0, score);
  }

  /**
   * Calculate reading time for content (in minutes)
   */
  private calculateReadingTime(content: string): number {
    const words = this.countWords(content);
    const wordsPerMinute = 200; // Average reading speed
    return Math.max(1, Math.ceil(words / wordsPerMinute));
  }

  /**
   * Calculate reading time for text (in minutes)
   */
  private calculateReadingTimeForText(text: string): number {
    const words = this.countWords(text);
    const wordsPerMinute = 200;
    return Math.max(0.5, Math.ceil(words / wordsPerMinute));
  }

  /**
   * Format reading time for display
   */
  private formatReadingTime(minutes: number): string {
    if (minutes < 1) {
      return 'Less than 1 minute';
    } else if (minutes === 1) {
      return '1 minute';
    } else {
      return `${minutes} minutes`;
    }
  }

  /**
   * Count words in content
   */
  private countWords(content: string): number {
    // Remove HTML tags and count words
    const text = content.replace(/<[^>]*>/g, ' ');
    return text.split(/\s+/).filter(w => w.length > 0).length;
  }

  /**
   * Count paragraphs in content
   */
  private countParagraphs(content: string): number {
    const paragraphRegex = /<p[^>]*>|<\/p>|<br\s*\/?>/gi;
    const matches = content.match(paragraphRegex) || [];
    return Math.max(1, matches.length / 2); // Approximate paragraph count
  }

  /**
   * Count headings in content
   */
  private countHeadings(content: string): number {
    const headingRegex = /<h[1-6][^>]*>/gi;
    return (content.match(headingRegex) || []).length;
  }

  /**
   * Count links in content
   */
  private countLinks(content: string): number {
    const linkRegex = /<a[^>]*>/gi;
    return (content.match(linkRegex) || []).length;
  }

  /**
   * Analyze content differences between versions
   */
  private analyzeContentDifferences(
    originalBlogPost: BlogPost,
    updatedBlogPost: BlogPost,
    comparison: any
  ): Array<{
    type: 'layout' | 'content' | 'style' | 'media';
    description: string;
    severity: 'low' | 'medium' | 'high';
  }> {
    const differences: Array<{
      type: 'layout' | 'content' | 'style' | 'media';
      description: string;
      severity: 'low' | 'medium' | 'high';
    }> = [];

    // Check for content changes
    if (originalBlogPost.content !== updatedBlogPost.content) {
      const originalWords = this.countWords(originalBlogPost.content);
      const updatedWords = this.countWords(updatedBlogPost.content);
      const wordChange = Math.abs(originalWords - updatedWords);
      
      let severity: 'low' | 'medium' | 'high' = 'low';
      if (wordChange > 500) severity = 'high';
      else if (wordChange > 100) severity = 'medium';
      
      differences.push({
        type: 'content',
        description: `Content changed by ${wordChange} words`,
        severity
      });
    }

    // Check for image changes
    if (originalBlogPost.images.length !== updatedBlogPost.images.length) {
      differences.push({
        type: 'media',
        description: `Image count changed from ${originalBlogPost.images.length} to ${updatedBlogPost.images.length}`,
        severity: 'medium'
      });
    }

    // Check for layout changes from visual comparison
    if (comparison.diffPercentage && comparison.diffPercentage > 0.1) {
      differences.push({
        type: 'layout',
        description: `Visual layout changed (${(comparison.diffPercentage * 100).toFixed(1)}% difference)`,
        severity: comparison.diffPercentage > 0.3 ? 'high' : 'medium'
      });
    }

    // Check for style changes
    if (comparison.styleChanges && comparison.styleChanges.length > 0) {
      differences.push({
        type: 'style',
        description: `${comparison.styleChanges.length} style changes detected`,
        severity: comparison.styleChanges.length > 5 ? 'high' : 'medium'
      });
    }

    return differences;
  }

  /**
   * Calculate layout changes from comparison
   */
  private calculateLayoutChanges(comparison: any): number {
    if (!comparison.diffPercentage) return 0;
    return Math.round(comparison.diffPercentage * 100);
  }

  /**
   * Calculate content changes between blog posts
   */
  private calculateContentChanges(originalBlogPost: BlogPost, updatedBlogPost: BlogPost): number {
    const originalWords = this.countWords(originalBlogPost.content);
    const updatedWords = this.countWords(updatedBlogPost.content);
    
    if (originalWords === 0) return updatedWords > 0 ? 100 : 0;
    
    const change = Math.abs(originalWords - updatedWords);
    return Math.round((change / originalWords) * 100);
  }

  /**
   * Calculate style changes from comparison
   */
  private calculateStyleChanges(comparison: any): number {
    if (!comparison.styleChanges) return 0;
    return comparison.styleChanges.length;
  }
}
