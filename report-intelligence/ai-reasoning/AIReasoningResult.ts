/**
 * AI Reasoning Result - Phase 12
 * 
 * Interface definitions for AI reasoning results, entities, relationships,
 * inferences, recommendations, and reasoning context.
 */

import { DecompiledReport } from '../decompiler/DecompiledReport';
import { SchemaMappingResult } from '../schema-mapper/SchemaMappingResult';
import { ClassificationResult } from '../classification/ClassificationResult';
import { ComplianceResult } from '../compliance/ComplianceResult';

/**
 * AI Reasoning Result - Main result interface
 */
export interface AIReasoningResult {
  /** Unique identifier for this reasoning result */
  id: string;
  
  /** Timestamp when reasoning was performed */
  timestamp: Date;
  
  /** Source of the reasoning (e.g., 'decompiled-report', 'schema-mapping', 'classification') */
  sourceType: string;
  
  /** ID of the source object (e.g., report ID, mapping ID) */
  sourceId: string;
  
  /** Natural Language Understanding results */
  nluResults: NLUResult[];
  
  /** Knowledge graph entities extracted */
  entities: Entity[];
  
  /** Relationships between entities */
  relationships: Relationship[];
  
  /** Inferences generated by reasoning engine */
  inferences: Inference[];
  
  /** Recommendations for action */
  recommendations: Recommendation[];
  
  /** Confidence scores for different aspects */
  confidenceScores: ConfidenceScores;
  
  /** Metadata about the reasoning process */
  metadata: ReasoningMetadata;
  
  /** Integration with other phase results */
  phaseIntegration: PhaseIntegration;
}

/**
 * Natural Language Understanding Result
 */
export interface NLUResult {
  /** Type of NLU analysis (e.g., 'semantic', 'entity', 'relationship', 'intent') */
  type: string;
  
  /** Text analyzed */
  text: string;
  
  /** Start position in source text */
  start: number;
  
  /** End position in source text */
  end: number;
  
  /** Analysis results */
  analysis: {
    /** Semantic analysis results */
    semantic?: SemanticAnalysis;
    
    /** Entity extraction results */
    entities?: Entity[];
    
    /** Relationship extraction results */
    relationships?: Relationship[];
    
    /** Intent understanding results */
    intent?: IntentAnalysis;
    
    /** Sentiment analysis results */
    sentiment?: SentimentAnalysis;
  };
  
  /** Confidence score (0-100) */
  confidence: number;
}

/**
 * Semantic Analysis
 */
export interface SemanticAnalysis {
  /** Main topics identified */
  topics: string[];
  
  /** Key concepts */
  concepts: string[];
  
  /** Semantic roles (agent, patient, instrument, etc.) */
  roles: SemanticRole[];
  
  /** Discourse structure */
  discourse: DiscourseStructure;
  
  /** Coherence score */
  coherence: number;
}

/**
 * Semantic Role
 */
export interface SemanticRole {
  /** Role type (e.g., 'agent', 'patient', 'instrument', 'location', 'time') */
  type: string;
  
  /** Entity filling this role */
  entity: Entity;
  
  /** Confidence score */
  confidence: number;
}

/**
 * Discourse Structure
 */
export interface DiscourseStructure {
  /** Discourse segments */
  segments: DiscourseSegment[];
  
  /** Rhetorical relations between segments */
  relations: RhetoricalRelation[];
  
  /** Overall discourse coherence */
  coherence: number;
}

/**
 * Discourse Segment
 */
export interface DiscourseSegment {
  /** Segment text */
  text: string;
  
  /** Segment type (e.g., 'introduction', 'methodology', 'results', 'discussion', 'conclusion') */
  type: string;
  
  /** Start position */
  start: number;
  
  /** End position */
  end: number;
}

/**
 * Rhetorical Relation
 */
export interface RhetoricalRelation {
  /** Relation type (e.g., 'elaboration', 'contrast', 'cause', 'evidence', 'sequence') */
  type: string;
  
  /** Source segment ID */
  source: string;
  
  /** Target segment ID */
  target: string;
  
  /** Confidence score */
  confidence: number;
}

/**
 * Entity - Extracted entity from text
 */
export interface Entity {
  /** Unique entity ID */
  id: string;
  
  /** Entity text */
  text: string;
  
  /** Entity type (e.g., 'tree', 'species', 'location', 'client', 'project', 'date', 'measurement') */
  type: string;
  
  /** Entity subtype (e.g., 'oak', 'maple', 'pine' for species) */
  subtype?: string;
  
  /** Start position in source text */
  start: number;
  
  /** End position in source text */
  end: number;
  
  /** Confidence score (0-100) */
  confidence: number;
  
  /** Attributes of the entity */
  attributes: Record<string, any>;
  
  /** Links to knowledge graph concepts */
  knowledgeGraphLinks: KnowledgeGraphLink[];
}

/**
 * Relationship - Relationship between entities
 */
export interface Relationship {
  /** Unique relationship ID */
  id: string;
  
  /** Relationship type (e.g., 'part_of', 'located_at', 'owned_by', 'requires', 'conflicts_with') */
  type: string;
  
  /** Source entity ID */
  sourceEntityId: string;
  
  /** Target entity ID */
  targetEntityId: string;
  
  /** Confidence score (0-100) */
  confidence: number;
  
  /** Attributes of the relationship */
  attributes: Record<string, any>;
  
  /** Evidence for the relationship */
  evidence: RelationshipEvidence[];
}

/**
 * Relationship Evidence
 */
export interface RelationshipEvidence {
  /** Evidence text */
  text: string;
  
  /** Start position */
  start: number;
  
  /** End position */
  end: number;
  
  /** Evidence type (e.g., 'explicit', 'implicit', 'inferred') */
  type: string;
  
  /** Confidence score */
  confidence: number;
}

/**
 * Knowledge Graph Link
 */
export interface KnowledgeGraphLink {
  /** Knowledge graph concept ID */
  conceptId: string;
  
  /** Link type (e.g., 'instance_of', 'subclass_of', 'has_property') */
  type: string;
  
  /** Confidence score */
  confidence: number;
}

/**
 * Intent Analysis
 */
export interface IntentAnalysis {
  /** Primary intent */
  primaryIntent: string;
  
  /** Secondary intents */
  secondaryIntents: string[];
  
  /** Intent confidence scores */
  confidenceScores: Record<string, number>;
  
  /** Intent parameters */
  parameters: Record<string, any>;
}

/**
 * Sentiment Analysis
 */
export interface SentimentAnalysis {
  /** Overall sentiment (positive, negative, neutral, mixed) */
  overall: string;
  
  /** Sentiment score (-1 to 1) */
  score: number;
  
  /** Sentiment by aspect */
  aspects: SentimentAspect[];
}

/**
 * Sentiment Aspect
 */
export interface SentimentAspect {
  /** Aspect (e.g., 'tree_health', 'risk_level', 'project_complexity') */
  aspect: string;
  
  /** Sentiment (positive, negative, neutral) */
  sentiment: string;
  
  /** Sentiment score (-1 to 1) */
  score: number;
  
  /** Evidence text */
  evidence: string;
}

/**
 * Inference - Logical inference generated by reasoning engine
 */
export interface Inference {
  /** Unique inference ID */
  id: string;
  
  /** Inference type (e.g., 'deductive', 'inductive', 'abductive', 'temporal', 'spatial') */
  type: string;
  
  /** Inference statement */
  statement: string;
  
  /** Premises (evidence supporting the inference) */
  premises: Premise[];
  
  /** Conclusion */
  conclusion: string;
  
  /** Confidence score (0-100) */
  confidence: number;
  
  /** Inference rules used */
  rules: InferenceRule[];
  
  /** Application context */
  context: InferenceContext;
}

/**
 * Premise - Evidence supporting an inference
 */
export interface Premise {
  /** Premise statement */
  statement: string;
  
  /** Source of premise (e.g., 'text', 'knowledge_graph', 'schema', 'data') */
  source: string;
  
  /** Source ID */
  sourceId: string;
  
  /** Confidence in premise */
  confidence: number;
}

/**
 * Inference Rule
 */
export interface InferenceRule {
  /** Rule ID */
  id: string;
  
  /** Rule name */
  name: string;
  
  /** Rule pattern */
  pattern: string;
  
  /** Rule type (e.g., 'logical', 'temporal', 'spatial', 'causal') */
  type: string;
}

/**
 * Inference Context
 */
export interface InferenceContext {
  /** Domain context (e.g., 'arboriculture', 'compliance', 'safety', 'planning') */
  domain: string;
  
  /** Temporal context */
  temporal?: TemporalContext;
  
  /** Spatial context */
  spatial?: SpatialContext;
  
  /** Project context */
  project?: ProjectContext;
}

/**
 * Temporal Context
 */
export interface TemporalContext {
  /** Time reference */
  reference: Date;
  
  /** Temporal relations (e.g., 'before', 'after', 'during', 'overlaps') */
  relations: TemporalRelation[];
}

/**
 * Temporal Relation
 */
export interface TemporalRelation {
  /** Relation type */
  type: string;
  
  /** Related event */
  event: string;
  
  /** Confidence score */
  confidence: number;
}

/**
 * Spatial Context
 */
export interface SpatialContext {
  /** Location reference */
  reference: string;
  
  /** Spatial relations (e.g., 'near', 'within', 'adjacent_to', 'contains') */
  relations: SpatialRelation[];
}

/**
 * Spatial Relation
 */
export interface SpatialRelation {
  /** Relation type */
  type: string;
  
  /** Related location */
  location: string;
  
  /** Confidence score */
  confidence: number;
}

/**
 * Project Context
 */
export interface ProjectContext {
  /** Project ID */
  projectId: string;
  
  /** Project name */
  projectName: string;
  
  /** Project type */
  projectType: string;
}

/**
 * Recommendation - Action recommendation from AI reasoning
 */
export interface Recommendation {
  /** Unique recommendation ID */
  id: string;
  
  /** Recommendation type (e.g., 'content', 'structure', 'compliance', 'safety', 'efficiency') */
  type: string;
  
  /** Recommendation title */
  title: string;
  
  /** Recommendation description */
  description: string;
  
  /** Recommended action */
  action: string;
  
  /** Priority level (critical, high, medium, low) */
  priority: string;
  
  /** Confidence score (0-100) */
  confidence: number;
  
  /** Expected impact */
  impact: string;
  
  /** Effort required (low, medium, high) */
  effort: string;
  
  /** Related entities */
  relatedEntities: string[];
  
  /** Evidence supporting the recommendation */
  evidence: RecommendationEvidence[];
}

/**
 * Recommendation Evidence
 */
export interface RecommendationEvidence {
  /** Evidence type (e.g., 'data', 'rule', 'pattern', 'best_practice') */
  type: string;
  
  /** Evidence description */
  description: string;
  
  /** Source of evidence */
  source: string;
  
  /** Confidence in evidence */
  confidence: number;
}

/**
 * Confidence Scores for different aspects of reasoning
 */
export interface ConfidenceScores {
  /** Overall confidence score (0-100) */
  overall: number;
  
  /** NLU confidence */
  nlu: number;
  
  /** Entity extraction confidence */
  entityExtraction: number;
  
  /** Relationship extraction confidence */
  relationshipExtraction: number;
  
  /** Inference confidence */
  inference: number;
  
  /** Recommendation confidence */
  recommendation: number;
  
  /** Knowledge graph integration confidence */
  knowledgeGraph: number;
}

/**
 * Reasoning Metadata
 */
export interface ReasoningMetadata {
  /** Reasoning engine version */
  engineVersion: string;
  
  /** Processing time in milliseconds */
  processingTimeMs: number;
  
  /** Resources used */
  resources: {
    /** Memory usage in MB */
    memoryMb: number;
    
    /** CPU usage percentage */
    cpuPercent: number;
  };
  
  /** Configuration used */
  configuration: Record<string, any>;
  
  /** Errors encountered (if any) */
  errors: ReasoningError[];
  
  /** Warnings generated */
  warnings: ReasoningWarning[];
}

/**
 * Reasoning Error
 */
export interface ReasoningError {
  /** Error code */
  code: string;
  
  /** Error message */
  message: string;
  
  /** Error severity (error, warning, info) */
  severity: string;
  
  /** Error context */
  context: Record<string, any>;
  
  /** Timestamp */
  timestamp: Date;
}

/**
 * Reasoning Warning
 */
export interface ReasoningWarning {
  /** Warning code */
  code: string;
  
  /** Warning message */
  message: string;
  
  /** Warning severity */
  severity: string;
  
  /** Warning context */
  context: Record<string, any>;
  
  /** Timestamp */
  timestamp: Date;
}

/**
 * Phase Integration - Integration with other phase results
 */
export interface PhaseIntegration {
  /** Phase 1: Report Type Registry integration */
  phase1?: {
    /** Report type ID */
    reportTypeId: string;
    
    /** Report type name */
    reportTypeName: string;
    
    /** Integration confidence */
    confidence: number;
  };
  
  /** Phase 2: Decompiler integration */
  phase2?: {
    /** Decompiled report ID */
    decompiledReportId: string;
    
    /** Integration confidence */
    confidence: number;
  };
  
  /** Phase 3: Schema Mapper integration */
  phase3?: {
    /** Schema mapping result ID */
    mappingResultId: string;
    
    /** Integration confidence */
    confidence: number;
  };
  
  /** Phase 4: Schema Updater integration */
  phase4?: {
    /** Schema update actions */
    updateActions: any[];
    
    /** Integration confidence */
    confidence: number;
  };
  
  /** Phase 5: Style Learner integration */
  phase5?: {
    /** Style profile ID */
    styleProfileId: string;
    
    /** Integration confidence */
    confidence: number;
  };
  
  /** Phase 6: Classification Engine integration */
  phase6?: {
    /** Classification result ID */
    classificationResultId: string;
    
    /** Integration confidence */
    confidence: number;
  };
  
  /** Phase 7: Self-Healing Engine integration */
  phase7?: {
    /** Healing actions */
    healingActions: any[];
    
    /** Integration confidence */
    confidence: number;
  };
  
  /** Phase 8: Template Generator integration */
  phase8?: {
    /** Generated templates */
    templates: any[];
    
    /** Integration confidence */
    confidence: number;
  };
  
  /** Phase 9: Compliance Validator integration */
  phase9?: {
    /** Compliance result ID */
    complianceResultId: string;
    
    /** Integration confidence */
    confidence: number;
  };
  
  /** Phase 10: Reproduction Tester integration */
  phase10?: {
    /** Test results */
    testResults: any[];
    
    /** Integration confidence */
    confidence: number;
  };
  
  /** Phase 11: Benchmarking integration */
  phase11?: {
    /** Benchmark results */
    benchmarkResults: any[];
    
    /** Integration confidence */
    confidence: number;
  };
}

/**
 * Helper functions for AI Reasoning Result
 */
export class AIReasoningResultHelpers {
  /**
   * Create a new AI Reasoning Result
   */
  static create(
    sourceType: string,
    sourceId: string,
    nluResults: NLUResult[] = [],
    entities: Entity[] = [],
    relationships: Relationship[] = [],
    inferences: Inference[] = [],
    recommendations: Recommendation[] = []
  ): AIReasoningResult {
    const id = `air-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    
    return {
      id,
      timestamp: new Date(),
      sourceType,
      sourceId,
      nluResults,
      entities,
      relationships,
      inferences,
      recommendations,
      confidenceScores: {
        overall: this.calculateOverallConfidence(nluResults, entities, relationships, inferences, recommendations),
        nlu: this.calculateAverageConfidence(nluResults),
        entityExtraction: this.calculateAverageConfidence(entities),
        relationshipExtraction: this.calculateAverageConfidence(relationships),
        inference: this.calculateAverageConfidence(inferences),
        recommendation: this.calculateAverageConfidence(recommendations),
        knowledgeGraph: 0 // Will be calculated during knowledge graph integration
      },
      metadata: {
        engineVersion: '1.0.0',
        processingTimeMs: 0,
        resources: {
          memoryMb: 0,
          cpuPercent: 0
        },
        configuration: {},
        errors: [],
        warnings: []
      },
      phaseIntegration: {}
    };
  }
  
  /**
   * Calculate overall confidence score
   */
  private static calculateOverallConfidence(
    nluResults: NLUResult[],
    entities: Entity[],
    relationships: Relationship[],
    inferences: Inference[],
    recommendations: Recommendation[]
  ): number {
    const scores = [];
    
    if (nluResults.length > 0) {
      scores.push(this.calculateAverageConfidence(nluResults));
    }
    
    if (entities.length > 0) {
      scores.push(this.calculateAverageConfidence(entities));
    }
    
    if (relationships.length > 0) {
      scores.push(this.calculateAverageConfidence(relationships));
    }
    
    if (inferences.length > 0) {
      scores.push(this.calculateAverageConfidence(inferences));
    }
    
    if (recommendations.length > 0) {
      scores.push(this.calculateAverageConfidence(recommendations));
    }
    
    if (scores.length === 0) {
      return 0;
    }
    
    // Weighted average with more weight on inferences and recommendations
    const weights = [0.15, 0.15, 0.15, 0.3, 0.25];
    let weightedSum = 0;
    let weightSum = 0;
    
    for (let i = 0; i < Math.min(scores.length, weights.length); i++) {
      weightedSum += scores[i] * weights[i];
      weightSum += weights[i];
    }
    
    return Math.round(weightedSum / weightSum);
  }
  
  /**
   * Calculate average confidence from an array of objects with confidence property
   */
  private static calculateAverageConfidence(items: Array<{ confidence: number }>): number {
    if (items.length === 0) {
      return 0;
    }
    
    const sum = items.reduce((total, item) => total + item.confidence, 0);
    return Math.round(sum / items.length);
  }
  
  /**
   * Add an error to the reasoning result metadata
   */
  static addError(result: AIReasoningResult, code: string, message: string, severity: string = 'error', context: Record<string, any> = {}): void {
    result.metadata.errors.push({
      code,
      message,
      severity,
      context,
      timestamp: new Date()
    });
  }
  
  /**
   * Add a warning to the reasoning result metadata
   */
  static addWarning(result: AIReasoningResult, code: string, message: string, severity: string = 'warning', context: Record<string, any> = {}): void {
    result.metadata.warnings.push({
      code,
      message,
      severity,
      context,
      timestamp: new Date()
    });
  }
  
  /**
   * Update processing time in metadata
   */
  static updateProcessingTime(result: AIReasoningResult, processingTimeMs: number): void {
    result.metadata.processingTimeMs = processingTimeMs;
  }
  
  /**
   * Update resource usage in metadata
   */
  static updateResourceUsage(result: AIReasoningResult, memoryMb: number, cpuPercent: number): void {
    result.metadata.resources.memoryMb = memoryMb;
    result.metadata.resources.cpuPercent = cpuPercent;
  }
  
  /**
   * Add phase integration data
   */
  static addPhaseIntegration(result: AIReasoningResult, phaseNumber: number, integrationData: any): void {
    const phaseKey = `phase${phaseNumber}` as keyof PhaseIntegration;
    result.phaseIntegration[phaseKey] = integrationData;
  }
  
  /**
   * Get a summary of the reasoning result
   */
  static getSummary(result: AIReasoningResult): {
    id: string;
    sourceType: string;
    sourceId: string;
    overallConfidence: number;
    entityCount: number;
    relationshipCount: number;
    inferenceCount: number;
    recommendationCount: number;
    errorCount: number;
    warningCount: number;
  } {
    return {
      id: result.id,
      sourceType: result.sourceType,
      sourceId: result.sourceId,
      overallConfidence: result.confidenceScores.overall,
      entityCount: result.entities.length,
      relationshipCount: result.relationships.length,
      inferenceCount: result.inferences.length,
      recommendationCount: result.recommendations.length,
      errorCount: result.metadata.errors.length,
      warningCount: result.metadata.warnings.length
    };
  }
}