/**
 * Report Self-Healing Engine - Phase 7
 * SelfHealingAction Interface
 * 
 * Defines the structure for self-healing actions generated by the Report Self-Healing Engine.
 */

import type { SchemaMappingResult } from '../schema-mapper/SchemaMappingResult';
import type { ClassificationResult } from '../classification/ClassificationResult';

/**
 * Self-healing action types
 */
export type SelfHealingActionType =
  | 'addMissingSection'
  | 'addMissingField'
  | 'fixContradiction'
  | 'updateSchema'
  | 'updateTemplate'
  | 'updateAIGuidance'
  | 'addMissingComplianceRule'
  | 'addMissingTerminology'
  | 'fixStructuralContradiction'
  | 'fixMetadataContradiction'
  | 'resolveSchemaGap'
  | 'improveMappingConfidence'
  | 'enhanceClassification';

/**
 * Severity levels for self-healing actions
 */
export type SelfHealingSeverity =
  | 'low'
  | 'medium'
  | 'high'
  | 'critical';

/**
 * Target for self-healing actions
 */
export interface SelfHealingTarget {
  reportTypeId?: string;
  sectionId?: string;
  fieldId?: string;
  terminologyId?: string;
  complianceRuleId?: string;
  templateId?: string;
  aiGuidanceId?: string;
  schemaGapId?: string;
  mappingResultId?: string;
  classificationResultId?: string;
}

/**
 * Payload for different action types
 */
export type SelfHealingPayload =
  | AddMissingSectionPayload
  | AddMissingFieldPayload
  | FixContradictionPayload
  | UpdateSchemaPayload
  | UpdateTemplatePayload
  | UpdateAIGuidancePayload
  | AddMissingComplianceRulePayload
  | AddMissingTerminologyPayload
  | FixStructuralContradictionPayload
  | FixMetadataContradictionPayload
  | ResolveSchemaGapPayload
  | ImproveMappingConfidencePayload
  | EnhanceClassificationPayload;

/**
 * Payload for adding missing sections
 */
export interface AddMissingSectionPayload {
  sectionId: string;
  sectionName: string;
  description: string;
  required: boolean;
  suggestedContent?: string;
  aiGuidance?: string;
  position?: number;
}

/**
 * Payload for adding missing fields
 */
export interface AddMissingFieldPayload {
  fieldId: string;
  fieldName: string;
  fieldType: 'text' | 'number' | 'date' | 'boolean' | 'array' | 'object' | 'section' | 'compliance' | 'terminology';
  sectionId: string;
  defaultValue?: any;
  validationRules?: string[];
  description?: string;
}

/**
 * Payload for fixing contradictions
 */
export interface FixContradictionPayload {
  contradictionType: 'section_content' | 'metadata' | 'structure' | 'terminology' | 'compliance';
  description: string;
  sourceA: any;
  sourceB: any;
  resolution: 'use_source_a' | 'use_source_b' | 'merge' | 'create_new' | 'flag_for_review';
  mergedValue?: any;
}

/**
 * Payload for updating schema
 */
export interface UpdateSchemaPayload {
  schemaChange: 'add_section' | 'remove_section' | 'modify_section' | 'add_field' | 'remove_field' | 'modify_field';
  targetId: string;
  newDefinition: any;
  reason: string;
  versionImpact: 'major' | 'minor' | 'patch';
}

/**
 * Payload for updating templates
 */
export interface UpdateTemplatePayload {
  templateId: string;
  templateChanges: {
    sections?: any[];
    formatting?: any;
    placeholders?: any[];
  };
  reason: string;
}

/**
 * Payload for updating AI guidance
 */
export interface UpdateAIGuidancePayload {
  guidanceId: string;
  guidanceType: 'generation' | 'validation' | 'enhancement' | 'compliance';
  newGuidance: string;
  examples?: string[];
  reason: string;
}

/**
 * Payload for adding missing compliance rules
 */
export interface AddMissingComplianceRulePayload {
  ruleId: string;
  ruleName: string;
  description: string;
  standard: string;
  requirement: string;
  severity: 'critical' | 'warning' | 'info';
  applicableSections?: string[];
}

/**
 * Payload for adding missing terminology
 */
export interface AddMissingTerminologyPayload {
  term: string;
  definition: string;
  category: 'technical' | 'legal' | 'compliance' | 'species' | 'measurement' | 'general';
  context: string;
  synonyms?: string[];
  relatedTerms?: string[];
}

/**
 * Payload for fixing structural contradictions
 */
export interface FixStructuralContradictionPayload {
  contradictionDescription: string;
  structureA: any;
  structureB: any;
  resolution: 'use_structure_a' | 'use_structure_b' | 'merge_structures' | 'create_new_structure';
  mergedStructure?: any;
}

/**
 * Payload for fixing metadata contradictions
 */
export interface FixMetadataContradictionPayload {
  contradictionDescription: string;
  metadataA: any;
  metadataB: any;
  resolution: 'use_metadata_a' | 'use_metadata_b' | 'merge_metadata' | 'create_new_metadata';
  mergedMetadata?: any;
}

/**
 * Payload for resolving schema gaps
 */
export interface ResolveSchemaGapPayload {
  gapId: string;
  gapType: 'missing_field' | 'missing_section' | 'unknown_section' | 'unknown_terminology' | 'unsupported_structure' | 'mismatched_schema';
  resolution: 'add_field' | 'add_section' | 'add_terminology' | 'update_schema' | 'ignore' | 'flag_for_review';
  resolutionDetails: any;
}

/**
 * Payload for improving mapping confidence
 */
export interface ImproveMappingConfidencePayload {
  mappingResultId: string;
  lowConfidenceMappings: Array<{
    fieldId: string;
    currentConfidence: number;
    suggestedImprovement: 'better_matching' | 'additional_data' | 'schema_update' | 'manual_review';
    improvementDetails: string;
  }>;
}

/**
 * Payload for enhancing classification
 */
export interface EnhanceClassificationPayload {
  classificationResultId: string;
  ambiguityLevel: 'none' | 'low' | 'medium' | 'high' | 'very-high';
  enhancementStrategy: 'add_report_type' | 'improve_scoring' | 'add_training_data' | 'manual_review';
  enhancementDetails: string;
}

/**
 * Self-healing action
 */
export interface SelfHealingAction {
  id: string;
  type: SelfHealingActionType;
  target: SelfHealingTarget;
  payload: SelfHealingPayload;
  severity: SelfHealingSeverity;
  reason: string;
  timestamps: {
    created: string;
    updated?: string;
    applied?: string;
  };
  status: 'pending' | 'approved' | 'applied' | 'rejected' | 'failed';
  source: {
    mappingResultId?: string;
    classificationResultId?: string;
    detector: string;
    confidence: number; // 0-1
  };
  dependencies?: string[]; // IDs of other actions this depends on
  notes?: string;
}

/**
 * Self-healing action batch
 */
export interface SelfHealingActionBatch {
  id: string;
  actions: SelfHealingAction[];
  source: {
    mappingResultId: string;
    classificationResultId?: string;
  };
  timestamps: {
    created: string;
    completed?: string;
  };
  summary: {
    totalActions: number;
    bySeverity: Record<SelfHealingSeverity, number>;
    byType: Record<SelfHealingActionType, number>;
    byStatus: Record<SelfHealingAction['status'], number>;
  };
}

/**
 * Create a self-healing action
 */
export function createSelfHealingAction(
  type: SelfHealingActionType,
  target: SelfHealingTarget,
  payload: SelfHealingPayload,
  severity: SelfHealingSeverity,
  reason: string,
  source: SelfHealingAction['source']
): SelfHealingAction {
  const now = new Date().toISOString();
  
  return {
    id: `healing_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    type,
    target,
    payload,
    severity,
    reason,
    timestamps: {
      created: now
    },
    status: 'pending',
    source,
    dependencies: [],
    notes: ''
  };
}

/**
 * Create a self-healing action batch
 */
export function createSelfHealingActionBatch(
  mappingResultId: string,
  actions: SelfHealingAction[],
  classificationResultId?: string
): SelfHealingActionBatch {
  const now = new Date().toISOString();
  
  // Calculate summary
  const bySeverity: Record<SelfHealingSeverity, number> = {
    low: 0,
    medium: 0,
    high: 0,
    critical: 0
  };
  
  // Initialize byType with all possible action types set to 0
  const byType: Record<SelfHealingActionType, number> = {
    addMissingSection: 0,
    addMissingField: 0,
    fixContradiction: 0,
    updateSchema: 0,
    updateTemplate: 0,
    updateAIGuidance: 0,
    addMissingComplianceRule: 0,
    addMissingTerminology: 0,
    fixStructuralContradiction: 0,
    fixMetadataContradiction: 0,
    resolveSchemaGap: 0,
    improveMappingConfidence: 0,
    enhanceClassification: 0
  };
  
  const byStatus: Record<SelfHealingAction['status'], number> = {
    pending: 0,
    approved: 0,
    applied: 0,
    rejected: 0,
    failed: 0
  };
  
  actions.forEach(action => {
    bySeverity[action.severity] = (bySeverity[action.severity] || 0) + 1;
    byType[action.type] = (byType[action.type] || 0) + 1;
    byStatus[action.status] = (byStatus[action.status] || 0) + 1;
  });
  
  return {
    id: `batch_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    actions,
    source: {
      mappingResultId,
      classificationResultId
    },
    timestamps: {
      created: now
    },
    summary: {
      totalActions: actions.length,
      bySeverity,
      byType,
      byStatus
    }
  };
}

/**
 * Validate a self-healing action
 */
export function validateSelfHealingAction(
  action: SelfHealingAction
): { isValid: boolean; errors: string[] } {
  const errors: string[] = [];
  
  if (!action.id) errors.push('Missing id');
  if (!action.type) errors.push('Missing type');
  if (!action.target) errors.push('Missing target');
  if (!action.payload) errors.push('Missing payload');
  if (!action.severity) errors.push('Missing severity');
  if (!action.reason) errors.push('Missing reason');
  if (!action.timestamps?.created) errors.push('Missing created timestamp');
  if (!action.status) errors.push('Missing status');
  if (!action.source) errors.push('Missing source');
  
  // Validate severity
  const validSeverities: SelfHealingSeverity[] = ['low', 'medium', 'high', 'critical'];
  if (!validSeverities.includes(action.severity)) {
    errors.push(`Invalid severity: ${action.severity}`);
  }
  
  // Validate status
  const validStatuses: SelfHealingAction['status'][] = ['pending', 'approved', 'applied', 'rejected', 'failed'];
  if (!validStatuses.includes(action.status)) {
    errors.push(`Invalid status: ${action.status}`);
  }
  
  // Validate source confidence
  if (action.source.confidence < 0 || action.source.confidence > 1) {
    errors.push('Source confidence must be between 0 and 1');
  }
  
  return {
    isValid: errors.length === 0,
    errors
  };
}

/**
 * Get action priority based on severity and confidence
 */
export function getActionPriority(action: SelfHealingAction): number {
  const severityWeights: Record<SelfHealingSeverity, number> = {
    low: 1,
    medium: 2,
    high: 3,
    critical: 4
  };
  
  const severityWeight = severityWeights[action.severity];
  const confidenceWeight = action.source.confidence;
  
  // Priority = severity * confidence
  return severityWeight * confidenceWeight;
}

/**
 * Sort actions by priority (highest first)
 */
export function sortActionsByPriority(actions: SelfHealingAction[]): SelfHealingAction[] {
  return [...actions].sort((a, b) => {
    const priorityA = getActionPriority(a);
    const priorityB = getActionPriority(b);
    return priorityB - priorityA; // Descending
  });
}

/**
 * Filter actions by severity
 */
export function filterActionsBySeverity(
  actions: SelfHealingAction[],
  severity: SelfHealingSeverity | SelfHealingSeverity[]
): SelfHealingAction[] {
  const severities = Array.isArray(severity) ? severity : [severity];
  return actions.filter(action => severities.includes(action.severity));
}

/**
 * Filter actions by type
 */
export function filterActionsByType(
  actions: SelfHealingAction[],
  type: SelfHealingActionType | SelfHealingActionType[]
): SelfHealingAction[] {
  const types = Array.isArray(type) ? type : [type];
  return actions.filter(action => types.includes(action.type));
}

/**
 * Update action status
 */
export function updateActionStatus(
  action: SelfHealingAction,
  status: SelfHealingAction['status'],
  notes?: string
): SelfHealingAction {
  const now = new Date().toISOString();
  
  return {
    ...action,
    status,
    timestamps: {
      ...action.timestamps,
      updated: now,
      ...(status === 'applied' ? { applied: now } : {})
    },
    notes: notes ? (action.notes ? `${action.notes}\n${notes}` : notes) : action.notes
  };
}