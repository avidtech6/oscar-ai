/**
 * Agent Types
 * 
 * Defines the background intelligence layer for Oscar AI's Communication Hub.
 * Supports autonomous agents, event listeners, periodic scanning, memory-driven triggers,
 * workflow auto-start, and "always-on" intelligence.
 */

/**
 * Agent type - determines how the agent is triggered
 */
export type AgentType =
	| 'periodic'           // Runs on a schedule
	| 'event'              // Triggered by events
	| 'memory'             // Triggered by memory changes
	| 'workflow_trigger'   // Triggers workflows
	| 'provider_monitor'   // Monitors provider health
	| 'deliverability_monitor' // Monitors deliverability
	| 'document_monitor'   // Monitors document lifecycle
	| 'thread_monitor'     // Monitors thread activity
	| 'style_monitor'      // Monitors style learning
	| 'client_monitor'     // Monitors client behavior
	| 'inbox_scanner'      // Scans inbox for opportunities
	| 'workflow_opportunity' // Identifies workflow opportunities

/**
 * Agent status
 */
export type AgentStatus =
	| 'idle'      // Agent is registered but not running
	| 'starting'  // Agent is starting up
	| 'running'   // Agent is actively running
	| 'paused'    // Agent is paused
	| 'stopping'  // Agent is stopping
	| 'stopped'   // Agent is stopped
	| 'error'     // Agent encountered an error

/**
 * Agent trigger configuration
 */
export interface AgentTrigger {
	/** Type of trigger */
	type: 'periodic' | 'event' | 'memory' | 'workflow' | 'manual';
	
	/** Trigger configuration */
	config: {
		/** For periodic triggers: interval in milliseconds */
		intervalMs?: number;
		
		/** For event triggers: event types to listen for */
		eventTypes?: string[];
		
		/** For memory triggers: memory categories to monitor */
		memoryCategories?: string[];
		
		/** For memory triggers: memory sources to monitor */
		memorySources?: string[];
		
		/** For workflow triggers: workflow IDs to monitor */
		workflowIds?: string[];
		
		/** Minimum importance threshold for memory triggers */
		minImportance?: number;
		
		/** Minimum confidence threshold for memory triggers */
		minConfidence?: number;
	};
}

/**
 * Agent schedule
 */
export interface AgentSchedule {
	/** When the agent should run */
	when: 'immediate' | 'delayed' | 'scheduled' | 'conditional';
	
	/** Delay in milliseconds (for delayed) */
	delayMs?: number;
	
	/** Scheduled time (for scheduled) */
	scheduledTime?: Date;
	
	/** Condition to check (for conditional) */
	condition?: () => boolean | Promise<boolean>;
}

/**
 * Agent context - data available to agents during execution
 */
export interface AgentContext {
	/** Current timestamp */
	timestamp: Date;
	
	/** Trigger that activated the agent */
	trigger?: {
		type: string;
		data?: any;
	};
	
	/** Memory engine instance */
	memoryEngine?: any;
	
	/** Workflow engine instance */
	workflowEngine?: any;
	
	/** Orchestrator instance */
	orchestrator?: any;
	
	/** Agent state */
	agentState: AgentState;
	
	/** Additional context data */
	data?: Record<string, any>;
}

/**
 * Agent result
 */
export interface AgentResult {
	/** Whether the agent execution was successful */
	success: boolean;
	
	/** Result data */
	data?: any;
	
	/** Error message if failed */
	error?: string;
	
	/** Suggestions generated by the agent */
	suggestions?: string[];
	
	/** Workflows triggered by the agent */
	workflowsTriggered?: string[];
	
	/** Memories created by the agent */
	memoriesCreated?: string[];
	
	/** Actions taken by the agent */
	actionsTaken?: Array<{
		action: string;
		target: string;
		result: 'success' | 'partial' | 'failure';
	}>;
	
	/** Execution time in milliseconds */
	executionTimeMs: number;
}

/**
 * Agent configuration
 */
export interface AgentConfig {
	/** Unique agent identifier */
	id: string;
	
	/** Agent name */
	name: string;
	
	/** Agent description */
	description: string;
	
	/** Agent type */
	type: AgentType;
	
	/** Agent triggers */
	triggers: AgentTrigger[];
	
	/** Agent schedule */
	schedule?: AgentSchedule;
	
	/** Whether the agent is enabled by default */
	enabled: boolean;
	
	/** Priority (0-100, higher = more important) */
	priority: number;
	
	/** Maximum execution time in milliseconds */
	maxExecutionTimeMs: number;
	
	/** Whether to persist agent state */
	persistState: boolean;
	
	/** Whether to log agent activity */
	logActivity: boolean;
	
	/** Configuration specific to this agent type */
	agentSpecificConfig?: Record<string, any>;
}

/**
 * Agent state
 */
export interface AgentState {
	/** Agent ID */
	agentId: string;
	
	/** Current status */
	status: AgentStatus;
	
	/** Last execution time */
	lastExecutionTime?: Date;
	
	/** Next scheduled execution time */
	nextExecutionTime?: Date;
	
	/** Execution count */
	executionCount: number;
	
	/** Success count */
	successCount: number;
	
	/** Error count */
	errorCount: number;
	
	/** Last error message */
	lastError?: string;
	
	/** Last execution result */
	lastResult?: AgentResult;
	
	/** Average execution time in milliseconds */
	averageExecutionTimeMs: number;
	
	/** Whether the agent is paused by user */
	pausedByUser: boolean;
	
	/** Pause reason */
	pauseReason?: string;
	
	/** Agent-specific state data */
	agentData?: Record<string, any>;
	
	/** Last updated timestamp */
	lastUpdated: Date;
}

/**
 * Agent event
 */
export interface AgentEvent {
	/** Event type */
	type:
		| 'agent_start'
		| 'agent_stop'
		| 'agent_pause'
		| 'agent_resume'
		| 'agent_tick'
		| 'agent_trigger'
		| 'agent_error'
		| 'agent_result'
		| 'agent_suggestion'
		| 'agent_workflow_triggered';
	
	/** Agent ID */
	agentId: string;
	
	/** Timestamp */
	timestamp: Date;
	
	/** Event data */
	data?: any;
	
	/** Error information (for error events) */
	error?: string;
}

/**
 * Agent - the core agent interface
 */
export interface Agent {
	/** Agent configuration */
	config: AgentConfig;
	
	/** Agent state */
	state: AgentState;
	
	/**
	 * Initialize the agent
	 */
	initialize(context: AgentContext): Promise<void>;
	
	/**
	 * Execute the agent
	 */
	execute(context: AgentContext): Promise<AgentResult>;
	
	/**
	 * Handle agent pause
	 */
	pause(reason?: string): Promise<void>;
	
	/**
	 * Handle agent resume
	 */
	resume(): Promise<void>;
	
	/**
	 * Handle agent stop
	 */
	stop(): Promise<void>;
	
	/**
	 * Clean up agent resources
	 */
	cleanup(): Promise<void>;
	
	/**
	 * Get agent suggestions
	 */
	getSuggestions(context: AgentContext): Promise<string[]>;
	
	/**
	 * Get agent status
	 */
	getStatus(): AgentStatus;
	
	/**
	 * Update agent state
	 */
	updateState(updates: Partial<AgentState>): void;
}

/**
 * Agent registry entry
 */
export interface AgentRegistryEntry {
	/** Agent ID */
	id: string;
	
	/** Agent configuration */
	config: AgentConfig;
	
	/** Agent factory function */
	factory: (config: AgentConfig) => Promise<Agent>;
	
	/** Whether the agent is registered */
	registered: boolean;
	
	/** Registration timestamp */
	registeredAt: Date;
}

/**
 * Agent engine configuration
 */
export interface AgentEngineConfig {
	/** Whether to auto-start enabled agents */
	autoStartEnabledAgents: boolean;
	
	/** Whether to persist agent state */
	persistAgentState: boolean;
	
	/** Whether to restore agent state on startup */
	restoreAgentState: boolean;
	
	/** Maximum concurrent agents */
	maxConcurrentAgents: number;
	
	/** Agent state persistence interval in milliseconds */
	statePersistenceIntervalMs: number;
	
	/** Whether to emit agent events */
	emitAgentEvents: boolean;
	
	/** Whether to log agent activity */
	logAgentActivity: boolean;
	
	/** Default agent priority */
	defaultAgentPriority: number;
	
	/** Default max execution time in milliseconds */
	defaultMaxExecutionTimeMs: number;
}

/**
 * Agent scheduler configuration
 */
export interface AgentSchedulerConfig {
	/** Maximum scheduled agents */
	maxScheduledAgents: number;
	
	/** Scheduler tick interval in milliseconds */
	schedulerTickIntervalMs: number;
	
	/** Whether to use requestAnimationFrame for browser environments */
	useRequestAnimationFrame: boolean;
	
	/** Whether to use web workers for heavy agents */
	useWebWorkers: boolean;
	
	/** Maximum retry attempts for failed agents */
	maxRetryAttempts: number;
	
	/** Retry delay in milliseconds */
	retryDelayMs: number;
}

/**
 * Agent state manager configuration
 */
export interface AgentStateManagerConfig {
	/** Whether to persist agent state to storage */
	persistToStorage: boolean;
	
	/** Storage key prefix */
	storageKeyPrefix: string;
	
	/** Maximum state history entries per agent */
	maxStateHistoryEntries: number;
	
	/** State persistence interval in milliseconds */
	persistenceIntervalMs: number;
	
	/** Whether to compress state data */
	compressStateData: boolean;
}